---
---

# Research Design & Analysis in R

## Environment Setup

First, let's import the library needed for our analysis.

```{r warning=FALSE, message=FALSE}
library(sf)
library(tmap)
```

Let's also bring in our data, cleaned from the previous module. In this case, we'll read from saved files and load in. You can access the sample data [here]().

## Variable Calculations

### Buffers

**Activity: Farmers Markets in Chicago**

This activity focuses on utilizing data from Chicago's farmers' markets, specifically the `farmers_markets_2012` dataset. 

Farmers' markets are vital for health and well-being, providing access to fresh, locally-grown produce and supporting sustainable food systems. They offer diverse, nutritious food options, often at affordable prices, and foster community connections and local agriculture support. The presence and density of farmers' markets in a neighborhood significantly influence residents' food accessibility.

#### Add Dataset

First, read in and inspect the shapefile file.

```{r }

markets <- st_read("data/farmers_markets_2012.shp")

head(markets)

```

We can see that the point data is already in a CRS that uses feet for distance, which is great. If the dataset had a different CRS, we would need to reproject to a new CRS. (See Module 4 for a refresh.)

Just to be sure, map the data with a basemap. 

```{r }

tmap_mode("view")

tm_basemap("CartoDB.Voyager") + 
  tm_shape(markets) + tm_dots(size=0.01) 

```


When mapping points in tmap, we can use the `tm_dots` or `tm_bubble` paramter. The bubbles function can make points bigger or smaller, depending on some attribute of the points. Here, we just want to map the point on its own, so we use `tm_dots`.

#### Create Buffers

Next, we can create a buffer. We use the `st_buffer` function to calculate, passing the points and distance measure. 

To calculate a half mile buffer, we will use 2,640 feet as our input (since 2640 ft = 0.5 mile).

``````{r }

markets.buffer <- st_buffer(markets, 2640)

```

Inspect right away! Map with your point data.

```{r }

tm_basemap("CartoDB.Voyager") + 
tm_shape(markets) + tm_dots(alpha=0.5) +
  tm_shape(markets.buffer) + tm_borders(alpha = 0.6)

```


You'll need to zoom in a bit to see the buffers! Let's try plotting using a standard map, with the Zip Codes we used previously.

First, read in the zips:

```{r }

zips <- st_read("data/chizips.geojson")

```
Next, let's overlay and add the buffers.

```{r }

tmap_mode("plot")

tm_shape(zips) + tm_borders(alpha=0.3) + tm_fill(col="gray90") +
  tm_shape(markets.buffer) + tm_fill(col = "turquoise1", alpha = 0.4) +
  tm_shape(markets) + tm_dots(size = 0.03) 

```

:::tip

**Tip**

To change the color in tmap, use the "col" parameter in most cases. R will recognize several standard color names, as well as codes used. Check out the [R Color Palette Cheat Sheet](https://www.nceas.ucsb.edu/sites/default/files/2020-04/colorPaletteCheatsheet.pdf) for more ideas.

:::

It's easy to add another buffer layer, and update your code with two! Let's add a 1-mile buffer as well.

```{r }

markets.buffer1 <- st_buffer(markets, 5280)

tm_shape(zips) + tm_borders(alpha=0.3) + tm_fill(col="gray90") +
  tm_shape(markets.buffer1) + tm_fill(col = "turquoise4", alpha = 0.4) +
  tm_shape(markets.buffer) + tm_fill(col = "turquoise1", alpha = 0.4) +
  tm_shape(markets) + tm_dots(size = 0.03) 

```

#### Dissolve Buffers

By viewing individual buffers distinctly, and playing with alpha (i.e. transparency) of the buffer visually, we can begin to get an idea of how intersecting areas of multiple markets look. Areas with more markets will have denser, intersecting buffers.

In some cases, the plentitude of resources nearby may not be as important as knowing whether or not a place is serviced by the resource at all.

If we consider the buffer as a service area, by dissolving boundaries of buffers, we can generate a uniform service area. To do this, we will dissolve the boundaries of buffers. It's also known as a buffer **union**.

We'll create two unions; one for the half mile buffers, and one for the mile buffers. Then, we visualize to inspect immediately.

```{r }

buffer.union <- st_union(markets.buffer)
buffer.union1 <- st_union(markets.buffer1)

tm_shape(zips) + tm_borders(alpha=0.3) + tm_fill(col="gray90") +
  tm_shape(buffer.union1) + tm_polygons(col = "turquoise4", alpha = 0.4) +
  tm_shape(buffer.union) + tm_fill(col = "turquoise1", alpha = 0.4) +
  tm_shape(markets) + tm_dots(size = 0.03) 

```

In this visualization, we switched to `tm_polygons` for the 1-mile buffer union to automatically add a border. This border cleanly highlights the union.

:::tip

**Tip**

You can use `st_union` to dissolve any other vector layers or spatial objects. It unions input geometries, merging to produce a resulting geometry with no overlaps. It's a very powerful function. 

:::

### Distance Metrics

Distance to the nearest resource is a common metric used to capture the availability of a resource, and in this tutorial we demonstrate how to calculate a minimum distance value from a ZCTA centroid to a set of resources.

Each zip code will be assigned a “minimum distance access metric” as a value that indicates access to resources from that zip code.

#### Centroid Calculation

First, let's calculate a centroid.

```{r }

zipCentroid <- st_centroid(zips)

```

Plot to confirm it looks right!

```{r }

tm_shape(zips) + tm_borders(alpha=0.3) + tm_fill(col="gray90") +
  tm_shape(zipCentroid) + tm_dots(col = "violetred1", size = 0.03) 

```

#### Standardize CRS

Next, as we will be working with two spatial datasets to generate the calculation, we need to ensure they're in the same CRS. First, inspect the CRS.

```{r }

st_crs(zipCentroid)

st_crs(markets)

```
It appears they are both using EPSG:3435 as their ID, so we should be set! If not, go back and transform to the standard CRS (that will use a meaningful distance unit).

#### Find Nearest Resource

First, we'll develop an index that identifies which market is nearest to the zip code centroid using the `st_nearest_feature` function. It will return the index of the object that is nearest, so we will subset the resources by the index to get the nearest object.

We can use the `str` or structure function to inspect the structure of the index for clarity. There are 58 items, corresponding to the 58 zip codes. In each slot, we have the row ID of the market that was identified as the nearest.

```{r }

nearestMarket_indexe <- st_nearest_feature(zipCentroid, markets)

str(nearestMarket_indexe)


nearestMarket <- markets[nearestMarket_indexe,]

```
#### Calculate Distance

Now we can calculate the distance between each zip centroid and its nearest market. Inspect.

```{r }

minDist <- st_distance(zipCentroid, nearestMarket, by_element = TRUE)

head(minDist)

```

We have distance metrics! However, they're in feet. While we can just multiple by a conversion factor to get miles, our spatial object would still indicate the unit as feet. Here, we can bring it a new package, `units`, to switch units for us.

```{r }

#install.packages("units")

library(units)

minDist_mi <- set_units(minDist, "mi")

head(minDist_mi)

```

We are ready to bind our minimum distance vector back to our Zips! Use a "column bind" function, `cbind`, to get it done. Inspect.

```{r message=FALSE}

zips_final <- cbind(zips, minDist_mi)

#head(zips_final)
```

#### Visualize 

Put it all together in a map.

```{r}
tm_shape(zips_final) +
  tm_polygons("minDist_mi", style = 'quantile', palette = "GnBu", n=5,
              title = "Min.Distance (mi)") +
    tm_shape(markets) + tm_dots(size = 0.03) +
  tm_layout(main.title = "Distance from Zip Centroid \n to Nearest Farmers Market",
            main.title.position = "center",
            main.title.size = 1)
```

If needed, write and save your merged file for later use.

```{r}

#st_write(zips_final, "data/zips-final.geojson")

```


## Statistical Mapping

**Activity: Mapping the Covid-19 Pandemic**

We've played a bit with thematic maps previously, but not gone into depth just yet. In these activities, we'll use different statistical mapping techniques to examine one week of case rates of Covid-19 in Chicago, in the first fall of the pandemic. We'll use the same zip file we've been using thus far.

### Choropleth Maps

First we'll make a simple map. We generate a choropleth map of case rate data using quantile bins, and the Blue-Purple color palettef. As shared in a tip above, you can find an R color cheatsheet useful for identifying palette codes [here](https://www.nceas.ucsb.edu/sites/default/files/2020-04/colorPaletteCheatsheet.pdf).

```{r warning = FALSE, messages=FALSE}

tm_shape(zips_final) +
  tm_polygons("Case.Rate...Cumulative", style="quantile", pal="BuPu",
              title = "COVID Case Rate") 
```

Already we can generate some insight. Areas on the far West side of the city have some of the highest case rates. 

Next, we adjust some `tmap` parameters to improve our map. Now we switch to a red-yellow-green palette, and specify six bins for our quantile map. We flip the direction of the palette using a negative sign, so that red corresponds to areas with higher rates. We adjust transparency using an `alpha` parameter, and line thickness using the `lwd` parameter. We also update our layout.

```{r warning = FALSE, messages=FALSE}

tm_shape(zips_final) +
  tm_fill("Case.Rate...Cumulative", style="quantile", n=6, pal="-RdYlGn",
              title = "COVID Case Rate",alpha = 0.8) + 
  tm_borders(lwd = 0) + 
  tm_layout(main.title = "Walkable Methadone Service Areas",
            main.title.position = "center",
            main.title.size = 1,
            frame = FALSE)
```
In this view, the lone zip in the downtown area is further illuminated. We confirm higher rates on the West side, but with slightly more variability than when we used fewer bins.



### Cartograms

install.packages("cartogram")
library(cartogram)

https://cran.r-project.org/web/packages/cartogram/readme/README.html 

non-overlapping Circles Cartogram (Dorling el al. 1996)

test <- cartogram_dorling(Chi_Zipsf.3435, "TotHousing")
> tm_shape(Chi_Zipsf.3435) + tm_polygons() + tm_shape(test) + tm_polygons("TotHousing")

test <- cartogram_dorling(Chi_Zipsf.3435, "TotHousing", k = 3)
> tm_shape(Chi_Zipsf.3435) + tm_polygons() + tm_shape(test) + tm_polygons("TotHousing")

test <- cartogram_dorling(Chi_Zipsf.3435, "TotHousing", k = 9)
> tm_shape(Chi_Zipsf.3435) + tm_polygons() + tm_shape(test) + tm_polygons("TotHousing")

test <- cartogram_dorling(Chi_Zipsf.3435, "TotHousing", k = 2)
> tm_shape(Chi_Zipsf.3435) + tm_polygons() + tm_shape(test) + tm_polygons("TotHousing")


rubber sheet distortion algorithm (Dougenik et al. 1985)

test <- cartogram_ncont(Chi_Zipsf.3435, "TotHousing")
tm_shape(Chi_Zipsf.3435) + tm_polygons() + tm_shape(test) + tm_polygons("TotHousing")


## Design Tips

### ColorBrewer

### Cartograms