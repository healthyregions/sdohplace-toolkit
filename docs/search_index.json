[["05-analysisR.html", "A Research Design &amp; Analysis in R A.1 Environment Setup A.2 Variable Calculations A.3 Statistical Mapping A.4 Design Tips", " A Research Design &amp; Analysis in R A.1 Environment Setup First, let’s import the library needed for our analysis. library(sf) library(tmap) Let’s also bring in our data, cleaned from the previous module. In this case, we’ll read from saved files and load in. You can access the sample data here. A.2 Variable Calculations A.2.1 Buffers Activity: Farmers Markets in Chicago This activity focuses on utilizing data from Chicago’s farmers’ markets, specifically the farmers_markets_2012 dataset. Farmers’ markets are vital for health and well-being, providing access to fresh, locally-grown produce and supporting sustainable food systems. They offer diverse, nutritious food options, often at affordable prices, and foster community connections and local agriculture support. The presence and density of farmers’ markets in a neighborhood significantly influence residents’ food accessibility. A.2.1.1 Add Dataset First, read in and inspect the shapefile file. markets &lt;- st_read(&quot;data/farmers_markets_2012.shp&quot;) ## Reading layer `farmers_markets_2012&#39; from data source ## `/Users/maryniakolak/Code/sdhoplace-toolkit/data/farmers_markets_2012.shp&#39; ## using driver `ESRI Shapefile&#39; ## Simple feature collection with 44 features and 10 fields ## Geometry type: POINT ## Dimension: XY ## Bounding box: xmin: 1138319 ymin: 1831122 xmax: 1190755 ymax: 1946403 ## Projected CRS: NAD83 / Illinois East (ftUS) head(markets) ## Simple feature collection with 6 features and 10 fields ## Geometry type: POINT ## Dimension: XY ## Bounding box: xmin: 1165549 ymin: 1841668 xmax: 1182421 ymax: 1946403 ## Projected CRS: NAD83 / Illinois East (ftUS) ## LOCATION INTERSECTI DAY_ START_TIME ## 1 Bridgeport 35th &amp; Wallace Saturday 7:00 AM ## 2 Glenwood Sunday Market 6950 N Glenwood Sunday 9:00 AM ## 3 Loyola&#39;s Farmers Market 6556 N Sheridan Rd Monday 3:00 PM ## 4 Seaway Bank Farmer&#39;s Market 645 E 87th St Wednesday 9:00 AM ## 5 Beverly W 95th St &amp; S Longwood Dr Sunday 7:00 AM ## 6 Bronzeville 4400 S. Cottage Grove Ave Saturday 8:00 AM ## END_TIME START_DATE END_DATE WEBSITE ## 1 1:00 pm 2012-06-16 2012-10-06 http://www.chicagofarmersmarkets.us ## 2 3:00 PM 2012-06-03 2012-10-28 www.glenwoodsundaymarket.org ## 3 7:00 PM 2012-06-11 2012-10-15 http://www.luc.edu/farmersmarket/ ## 4 2:00 PM 2012-07-25 2012-09-26 http://www.seawaybank.us ## 5 1:00 PM 2012-05-13 2012-10-28 http://www.chicagofarmersmarkets.us ## 6 1:00 PM 2012-06-16 2012-10-27 http://www.qcdc.org ## TYPE LINK_ACCEP geometry ## 1 Weekly YES POINT (1172813 1881658) ## 2 Independent YES POINT (1165549 1946403) ## 3 Independent YES POINT (1167025 1943978) ## 4 Independent NO POINT (1182421 1847449) ## 5 Weekly YES POINT (1165573 1841668) ## 6 Independent YES POINT (1182325 1875662) We can see that the point data is already in a CRS that uses feet for distance, which is great. If the dataset had a different CRS, we would need to reproject to a new CRS. (See Module 4 for a refresh.) Just to be sure, map the data with a basemap. tmap_mode(&quot;view&quot;) ## tmap mode set to interactive viewing tm_basemap(&quot;CartoDB.Voyager&quot;) + tm_shape(markets) + tm_dots(size=0.01) When mapping points in tmap, we can use the tm_dots or tm_bubble paramter. The bubbles function can make points bigger or smaller, depending on some attribute of the points. Here, we just want to map the point on its own, so we use tm_dots. A.2.1.2 Create Buffers Next, we can create a buffer. We use the st_buffer function to calculate, passing the points and distance measure. To calculate a half mile buffer, we will use 2,640 feet as our input (since 2640 ft = 0.5 mile). markets.buffer &lt;- st_buffer(markets, 2640) Inspect right away! Map with your point data. tm_basemap(&quot;CartoDB.Voyager&quot;) + tm_shape(markets) + tm_dots(alpha=0.5) + tm_shape(markets.buffer) + tm_borders(alpha = 0.6) You’ll need to zoom in a bit to see the buffers! Let’s try plotting using a standard map, with the Zip Codes we used previously. First, read in the zips: zips &lt;- st_read(&quot;data/chizips.geojson&quot;) ## Reading layer `chizips&#39; from data source ## `/Users/maryniakolak/Code/sdhoplace-toolkit/data/chizips.geojson&#39; ## using driver `GeoJSON&#39; ## Simple feature collection with 58 features and 63 fields ## Geometry type: MULTIPOLYGON ## Dimension: XY ## Bounding box: xmin: 1108622 ymin: 1813892 xmax: 1205199 ymax: 1951669 ## Projected CRS: NAD83 / Illinois East (ftUS) Next, let’s overlay and add the buffers. tmap_mode(&quot;plot&quot;) ## tmap mode set to plotting tm_shape(zips) + tm_borders(alpha=0.3) + tm_fill(col=&quot;gray90&quot;) + tm_shape(markets.buffer) + tm_fill(col = &quot;turquoise1&quot;, alpha = 0.4) + tm_shape(markets) + tm_dots(size = 0.03) Tip To change the color in tmap, use the “col” parameter in most cases. R will recognize several standard color names, as well as codes used. Check out the R Color Palette Cheat Sheet for more ideas. It’s easy to add another buffer layer, and update your code with two! Let’s add a 1-mile buffer as well. markets.buffer1 &lt;- st_buffer(markets, 5280) tm_shape(zips) + tm_borders(alpha=0.3) + tm_fill(col=&quot;gray90&quot;) + tm_shape(markets.buffer1) + tm_fill(col = &quot;turquoise4&quot;, alpha = 0.4) + tm_shape(markets.buffer) + tm_fill(col = &quot;turquoise1&quot;, alpha = 0.4) + tm_shape(markets) + tm_dots(size = 0.03) A.2.1.3 Dissolve Buffers By viewing individual buffers distinctly, and playing with alpha (i.e. transparency) of the buffer visually, we can begin to get an idea of how intersecting areas of multiple markets look. Areas with more markets will have denser, intersecting buffers. In some cases, the plentitude of resources nearby may not be as important as knowing whether or not a place is serviced by the resource at all. If we consider the buffer as a service area, by dissolving boundaries of buffers, we can generate a uniform service area. To do this, we will dissolve the boundaries of buffers. It’s also known as a buffer union. We’ll create two unions; one for the half mile buffers, and one for the mile buffers. Then, we visualize to inspect immediately. buffer.union &lt;- st_union(markets.buffer) buffer.union1 &lt;- st_union(markets.buffer1) tm_shape(zips) + tm_borders(alpha=0.3) + tm_fill(col=&quot;gray90&quot;) + tm_shape(buffer.union1) + tm_polygons(col = &quot;turquoise4&quot;, alpha = 0.4) + tm_shape(buffer.union) + tm_fill(col = &quot;turquoise1&quot;, alpha = 0.4) + tm_shape(markets) + tm_dots(size = 0.03) In this visualization, we switched to tm_polygons for the 1-mile buffer union to automatically add a border. This border cleanly highlights the union. Tip You can use st_union to dissolve any other vector layers or spatial objects. It unions input geometries, merging to produce a resulting geometry with no overlaps. It’s a very powerful function. A.2.2 Distance Metrics Distance to the nearest resource is a common metric used to capture the availability of a resource, and in this tutorial we demonstrate how to calculate a minimum distance value from a ZCTA centroid to a set of resources. Each zip code will be assigned a “minimum distance access metric” as a value that indicates access to resources from that zip code. A.2.2.1 Centroid Calculation First, let’s calculate a centroid. zipCentroid &lt;- st_centroid(zips) ## Warning: st_centroid assumes attributes are constant over geometries Plot to confirm it looks right! tm_shape(zips) + tm_borders(alpha=0.3) + tm_fill(col=&quot;gray90&quot;) + tm_shape(zipCentroid) + tm_dots(col = &quot;violetred1&quot;, size = 0.03) #### Standardize CRS Next, as we will be working with two spatial datasets to generate the calculation, we need to ensure they’re in the same CRS. First, inspect the CRS. st_crs(zipCentroid) ## Coordinate Reference System: ## User input: NAD83 / Illinois East (ftUS) ## wkt: ## PROJCRS[&quot;NAD83 / Illinois East (ftUS)&quot;, ## BASEGEOGCRS[&quot;NAD83&quot;, ## DATUM[&quot;North American Datum 1983&quot;, ## ELLIPSOID[&quot;GRS 1980&quot;,6378137,298.257222101, ## LENGTHUNIT[&quot;metre&quot;,1]]], ## PRIMEM[&quot;Greenwich&quot;,0, ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]], ## ID[&quot;EPSG&quot;,4269]], ## CONVERSION[&quot;SPCS83 Illinois East zone (US Survey feet)&quot;, ## METHOD[&quot;Transverse Mercator&quot;, ## ID[&quot;EPSG&quot;,9807]], ## PARAMETER[&quot;Latitude of natural origin&quot;,36.6666666666667, ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433], ## ID[&quot;EPSG&quot;,8801]], ## PARAMETER[&quot;Longitude of natural origin&quot;,-88.3333333333333, ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433], ## ID[&quot;EPSG&quot;,8802]], ## PARAMETER[&quot;Scale factor at natural origin&quot;,0.999975, ## SCALEUNIT[&quot;unity&quot;,1], ## ID[&quot;EPSG&quot;,8805]], ## PARAMETER[&quot;False easting&quot;,984250, ## LENGTHUNIT[&quot;US survey foot&quot;,0.304800609601219], ## ID[&quot;EPSG&quot;,8806]], ## PARAMETER[&quot;False northing&quot;,0, ## LENGTHUNIT[&quot;US survey foot&quot;,0.304800609601219], ## ID[&quot;EPSG&quot;,8807]]], ## CS[Cartesian,2], ## AXIS[&quot;easting (X)&quot;,east, ## ORDER[1], ## LENGTHUNIT[&quot;US survey foot&quot;,0.304800609601219]], ## AXIS[&quot;northing (Y)&quot;,north, ## ORDER[2], ## LENGTHUNIT[&quot;US survey foot&quot;,0.304800609601219]], ## USAGE[ ## SCOPE[&quot;Engineering survey, topographic mapping.&quot;], ## AREA[&quot;United States (USA) - Illinois - counties of Boone; Champaign; Clark; Clay; Coles; Cook; Crawford; Cumberland; De Kalb; De Witt; Douglas; Du Page; Edgar; Edwards; Effingham; Fayette; Ford; Franklin; Gallatin; Grundy; Hamilton; Hardin; Iroquois; Jasper; Jefferson; Johnson; Kane; Kankakee; Kendall; La Salle; Lake; Lawrence; Livingston; Macon; Marion; Massac; McHenry; McLean; Moultrie; Piatt; Pope; Richland; Saline; Shelby; Vermilion; Wabash; Wayne; White; Will; Williamson.&quot;], ## BBOX[37.06,-89.28,42.5,-87.02]], ## ID[&quot;EPSG&quot;,3435]] st_crs(markets) ## Coordinate Reference System: ## User input: NAD83 / Illinois East (ftUS) ## wkt: ## PROJCRS[&quot;NAD83 / Illinois East (ftUS)&quot;, ## BASEGEOGCRS[&quot;NAD83&quot;, ## DATUM[&quot;North American Datum 1983&quot;, ## ELLIPSOID[&quot;GRS 1980&quot;,6378137,298.257222101, ## LENGTHUNIT[&quot;metre&quot;,1]]], ## PRIMEM[&quot;Greenwich&quot;,0, ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]], ## ID[&quot;EPSG&quot;,4269]], ## CONVERSION[&quot;SPCS83 Illinois East zone (US Survey feet)&quot;, ## METHOD[&quot;Transverse Mercator&quot;, ## ID[&quot;EPSG&quot;,9807]], ## PARAMETER[&quot;Latitude of natural origin&quot;,36.6666666666667, ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433], ## ID[&quot;EPSG&quot;,8801]], ## PARAMETER[&quot;Longitude of natural origin&quot;,-88.3333333333333, ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433], ## ID[&quot;EPSG&quot;,8802]], ## PARAMETER[&quot;Scale factor at natural origin&quot;,0.999975, ## SCALEUNIT[&quot;unity&quot;,1], ## ID[&quot;EPSG&quot;,8805]], ## PARAMETER[&quot;False easting&quot;,984250, ## LENGTHUNIT[&quot;US survey foot&quot;,0.304800609601219], ## ID[&quot;EPSG&quot;,8806]], ## PARAMETER[&quot;False northing&quot;,0, ## LENGTHUNIT[&quot;US survey foot&quot;,0.304800609601219], ## ID[&quot;EPSG&quot;,8807]]], ## CS[Cartesian,2], ## AXIS[&quot;easting (X)&quot;,east, ## ORDER[1], ## LENGTHUNIT[&quot;US survey foot&quot;,0.304800609601219]], ## AXIS[&quot;northing (Y)&quot;,north, ## ORDER[2], ## LENGTHUNIT[&quot;US survey foot&quot;,0.304800609601219]], ## USAGE[ ## SCOPE[&quot;Engineering survey, topographic mapping.&quot;], ## AREA[&quot;United States (USA) - Illinois - counties of Boone; Champaign; Clark; Clay; Coles; Cook; Crawford; Cumberland; De Kalb; De Witt; Douglas; Du Page; Edgar; Edwards; Effingham; Fayette; Ford; Franklin; Gallatin; Grundy; Hamilton; Hardin; Iroquois; Jasper; Jefferson; Johnson; Kane; Kankakee; Kendall; La Salle; Lake; Lawrence; Livingston; Macon; Marion; Massac; McHenry; McLean; Moultrie; Piatt; Pope; Richland; Saline; Shelby; Vermilion; Wabash; Wayne; White; Will; Williamson.&quot;], ## BBOX[37.06,-89.28,42.5,-87.02]], ## ID[&quot;EPSG&quot;,3435]] It appears they are both using EPSG:3435 as their ID, so we should be set! If not, go back and transform to the standard CRS (that will use a meaningful distance unit). A.2.2.2 Find Nearest Resource First, we’ll develop an index that identifies which market is nearest to the zip code centroid using the st_nearest_feature function. It will return the index of the object that is nearest, so we will subset the resources by the index to get the nearest object. We can use the str or structure function to inspect the structure of the index for clarity. There are 58 items, corresponding to the 58 zip codes. In each slot, we have the row ID of the market that was identified as the nearest. nearestMarket_indexe &lt;- st_nearest_feature(zipCentroid, markets) str(nearestMarket_indexe) ## int [1:58] 32 32 32 8 16 7 18 31 23 33 ... nearestMarket &lt;- markets[nearestMarket_indexe,] A.2.2.3 Calculate Distance Now we can calculate the distance between each zip centroid and its nearest market. Inspect. minDist &lt;- st_distance(zipCentroid, nearestMarket, by_element = TRUE) head(minDist) ## Units: [US_survey_foot] ## [1] 1319.2011 596.7483 1422.5178 1130.9705 2669.0223 1897.2897 We have distance metrics! However, they’re in feet. While we can just multiple by a conversion factor to get miles, our spatial object would still indicate the unit as feet. Here, we can bring it a new package, units, to switch units for us. #install.packages(&quot;units&quot;) library(units) ## udunits database from /Library/Frameworks/R.framework/Versions/4.3-x86_64/Resources/library/units/share/udunits/udunits2.xml minDist_mi &lt;- set_units(minDist, &quot;mi&quot;) head(minDist_mi) ## Units: [mi] ## [1] 0.2498492 0.1130207 0.2694168 0.2141994 0.5054977 0.3593359 We are ready to bind our minimum distance vector back to our Zips! Use a “column bind” function, cbind, to get it done. Inspect. zips_final &lt;- cbind(zips, minDist_mi) #head(zips_final) A.2.2.4 Visualize Put it all together in a map. tm_shape(zips_final) + tm_polygons(&quot;minDist_mi&quot;, style = &#39;quantile&#39;, palette = &quot;GnBu&quot;, n=5, title = &quot;Min.Distance (mi)&quot;) + tm_shape(markets) + tm_dots(size = 0.03) + tm_layout(main.title = &quot;Distance from Zip Centroid \\n to Nearest Farmers Market&quot;, main.title.position = &quot;center&quot;, main.title.size = 1) If needed, write and save your merged file for later use. #st_write(zips_final, &quot;data/zips-final.geojson&quot;) A.3 Statistical Mapping A.3.1 Choropleth Maps A.3.2 Cartograms install.packages(“cartogram”) library(cartogram) https://cran.r-project.org/web/packages/cartogram/readme/README.html non-overlapping Circles Cartogram (Dorling el al. 1996) test &lt;- cartogram_dorling(Chi_Zipsf.3435, “TotHousing”) &gt; tm_shape(Chi_Zipsf.3435) + tm_polygons() + tm_shape(test) + tm_polygons(“TotHousing”) test &lt;- cartogram_dorling(Chi_Zipsf.3435, “TotHousing”, k = 3) &gt; tm_shape(Chi_Zipsf.3435) + tm_polygons() + tm_shape(test) + tm_polygons(“TotHousing”) test &lt;- cartogram_dorling(Chi_Zipsf.3435, “TotHousing”, k = 9) &gt; tm_shape(Chi_Zipsf.3435) + tm_polygons() + tm_shape(test) + tm_polygons(“TotHousing”) test &lt;- cartogram_dorling(Chi_Zipsf.3435, “TotHousing”, k = 2) &gt; tm_shape(Chi_Zipsf.3435) + tm_polygons() + tm_shape(test) + tm_polygons(“TotHousing”) rubber sheet distortion algorithm (Dougenik et al. 1985) test &lt;- cartogram_ncont(Chi_Zipsf.3435, “TotHousing”) tm_shape(Chi_Zipsf.3435) + tm_polygons() + tm_shape(test) + tm_polygons(“TotHousing”) A.4 Design Tips A.4.1 ColorBrewer A.4.2 Cartograms "]]
