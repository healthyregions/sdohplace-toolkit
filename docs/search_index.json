[["06-appdev-code.html", "B Coding for app development B.1 Getting Started with Github and Github Pages B.2 Leaflet Map with CSV and GeoJSON data B.3 R Shiny B.4 Conclusion", " B Coding for app development B.1 Getting Started with Github and Github Pages In these exercises we’ll begin working with a code sharing platform called Github that is used by software developers, researchers, and hobbyists all around the world. With a free account on Github, you are able to upload code bases and datasets into public repositories, allowing other people to see your work, contribute to it, or build from it. One especially useful tool that the platform provides is called Github Pages, a mechanism that allows you to turn any single repository into a publicly accessible website for free. Github Pages is a perfect way to create a personal website, blog, or portfolio site, but we can also use it to host and serve simple web maps and visualizations. The following tips will help you get started with Github. B.1.1 What is a Repository? A repository is any collection of code or data that is stored together as a unit. For example, the entire code base for Moodle, or [covid-19-data] downloads from the NY Times. B.1.2 Understanding Github’s URL Structure - Naming is important! Github is organized with a simple hierarchy: Account &gt; Repository Name, where accounts can be either individual users, or organizational accounts. For example, our HeRoP lab organization is healthyregions which means that our repository “sdohplace-toolkit” (this toolkit!) is located at https://github.com/healthyregions/sdohplace-toolkit. B.1.3 Creating an Account When you choose a username, pick something simple that can be shared easily, because, as described above, your username will be in public urls all the time. Additionally, when you publish a repository with Github Pages, that user name will become part of the URL for your page. B.2 Leaflet Map with CSV and GeoJSON data Leaflet is a very popular open source mapping library used to create interactive web maps. Leaflet is written in JavaScript, a programming language that runs in all web browsers, so creating a map with Leaflet will involve at least a bit of looking at and modifying code–HMTL, CSS, and JavaScript which are the foundational components of any webpage. Tip Our example builds from Leaflet Maps with CSV Data from HandsOnDataViz, a fantastic collection of guides and recipes for data visualization by Jack Dougherty and Ilya Ilyankou that focus on using open source and accessible technologies. We strongly encourage you to explore all of their other content as well! Generally speaking, libraries like Leaflet create web maps by defining an area of a web page, like a canvas, and then loading various geospatial data into that area, allowing users to pan, zoom, inspect, and interact with the content. In this example, we will create and publish a very simple web map using prepared CSV and GeoJSON datasets. At the end of the exercise, you should be able to swap these datasets out with your own, and have a basic understanding of how to modify Leaflet code. We will do all of our file storage and editing directly in Github, which will also allow us to immediately make our map publicly visible. B.3 R Shiny Getting Started Once you have a solid sense of R (see previous modules and recommended tutorials), you may be ready to make your first app! To develop an application quickly, we use the shiny package. Shiny is a web application framework for R that makes it easy to build interactive web apps straight from R. This particular application allows users to explore various demographic metrics through interactive maps and charts. install.packages(&quot;shiny&quot;) We recommend going through the beginner lessons on Shiny applications at Posit before diving into your app development directly. Get familiar with the basics, practice, and explore different example apps for ideas. As you go through these, resist the urge to try to incorporate everything into your own app. Follow the design-thinking process, user input, and diagrams you built in previous modules! A Shiny app can be contained in a single script, app.R, which will have the following three components: a user interface object a server function a call to the shinyApp function The application is structured into three main parts: the user interface (ui), the server logic (server), and the global setup where libraries are loaded and data is prepared. B.3.1 User Interface You can define the layout of your application using the user inferface, defining what goes where, how it looks, and what events are triggered. Upon loading the site, a default plot may be triggered to be oupit. A user may also select specific items within the user interface, like a variable from a drop-down panel, or sliding a slider. Using the example from Shiny’s official tutorial, copy and paste the following into a new file you’ll save as app.R in a folder on your computer. library(shiny) library(bslib) # Define UI ---- ui &lt;- page_sidebar( ) # Define server logic ---- server &lt;- function(input, output) { } # Run the app ---- shinyApp(ui = ui, server = server) Following the same example, add a title to your application, a sidebar, and a main section. In this example, we’ll make a an on SDOH indicators in NYC. library(shiny) library(bslib) # Define UI ---- ui &lt;- page_sidebar( title = &quot;NYC SDOH App&quot;, sidebar = sidebar(&quot;sidebar&quot;), &quot;main contents&quot; ) # Define server logic ---- server &lt;- function(input, output) { } # Run the app ---- shinyApp(ui = ui, server = server) Next, let’s add a drop down variable selection for a variable of interest we’d like to explore in the app. For example, we may want to examine data by self-identified race and ethnicity, as reported by neighborhood via the Census. We’ll add a drop-down widget, and “helper text” to explain what the user should do. library(shiny) library(bslib) # Define UI ---- ui &lt;- page_sidebar( title = &quot;NYC SDOH App&quot;, sidebar = sidebar( helpText(&quot;Select different variables from the dropdown menus to explore the data.&quot;), selectInput(&quot;color&quot;, &quot;Self-Identified Race &amp; Ethnicity:&quot;, choices = c(&quot;Percent Black&quot; = &quot;pctblack&quot;, &quot;Percent Hispanic&quot; = &quot;pcthisp&quot;, &quot;Percent White&quot; = &quot;pctwhite&quot;), selected = &quot;pctblack&quot;), ), ) # Define server logic ---- server &lt;- function(input, output) { } # Run the app ---- shinyApp(ui = ui, server = server) Ensure you’re running each time that you add, edit, or change anything. This helps with the troubleshooting process! By now, your application will be looking like this: Continue to explore the different layouts, widgets, themes, and options available to you in the Shiny documentation. B.3.2 Server When we’re running the application, we’re actually using our coomputers as the server. Let’s connect our drop down to data we’ll load in – NYC data – and use the user selection to generate a map. We recommend getting the script to work in a .R file on its own before plugging in, to confirm that it will work the way you need it to. De-bugging can be tricky in more complex applications, so anything you can do to support your process will be beneficial. We’ll jump a few steps ahead, to show what the full set up can look like: library(shiny) library(bslib) # Load data ---- nyc_data &lt;- st_read(&quot;NYC_nbrhd_data.geojson&quot;, quiet = TRUE) nyc_data &lt;- st_make_valid(nyc_data) map_data &lt;- st_transform(nyc_data, crs = 4326) # Define UI ---- ui &lt;- page_sidebar( title = &quot;NYC SDOH App&quot;, sidebar = sidebar( helpText(&quot;Select different variables from the dropdown menus to explore the data.&quot;), selectInput(&quot;color&quot;, &quot;Self-Identified Race &amp; Ethnicity:&quot;, choices = c(&quot;Percent Black&quot; = &quot;pctblack&quot;, &quot;Percent Hispanic&quot; = &quot;pcthisp&quot;, &quot;Percent White&quot; = &quot;pctwhite&quot;), selected = &quot;pctblack&quot;)), mainPanel( ## Add a map (leafletOutput(&quot;map&quot;, width = &quot;100%&quot;) ))) # Define server logic ---- server &lt;- function(input, output, session) { # Map output for Racial Demographics output$map &lt;- renderLeaflet({ valid_data &lt;- map_data[!is.na(map_data[[input$color]]), ] pal &lt;- colorQuantile(&quot;PuBuGn&quot;, valid_data[[input$color]], n = 5) leaflet(valid_data) %&gt;% addProviderTiles(providers$CartoDB.Positron) %&gt;% addPolygons( fillColor = ~pal(valid_data[[input$color]]), fillOpacity = 0.7, weight = 1, color = &quot;white&quot;, popup = ~paste(NTAName, &quot;&lt;br&gt;&quot;, paste(input$color, &quot;:&quot;, round(valid_data[[input$color]], 2), &quot;%&quot;)) ) %&gt;% setView(lng = -73.935242, lat = 40.730610, zoom = 10) }) } # Run the app ---- shinyApp(ui = ui, server = server) Inspect how the map output call was added to the UI. In the server function, the map data is slightly cleaned (from debugging in a script on its own), and a color palette is indicated using a ColorBrewer selection. Then, we use leaflet to visualize the variable selected by the user. Leaflet is more responsive than tmap, as used in previous sessions. B.3.3 Expand Your Prototype B.3.4 Step 1: Libraries and Data Preparation First, we need to load the necessary R packages. These libraries enable various functionalities: shiny for the app framework, leaflet for interactive maps, sf for handling geographic data, plotly for interactive charts, and dplyr for data manipulation. library(shiny) library(leaflet) library(sf) library(plotly) library(dplyr) Now, let’s load and prepare the NYC demographic GeoJSON data. This file format is commonly used for geographic data structures. nyc_data &lt;- st_read(&quot;NYC_nbrhd_data.geojson&quot;, quiet = TRUE) nyc_data &lt;- st_make_valid(nyc_data) nyc_data &lt;- st_transform(nyc_data, crs = 4326) B.3.5 Step 2: Define the User Interface The user interface is defined in a way that allows users to interact with the application. First, we aim to includes dropdown menus for selecting demographic variables and neighborhoods, and panels for displaying maps and charts. Then, we want the final UI organize into three main tabs, allowing users to interactively explore different facets of the NYC neighborhood data. B.3.5.1 Tab 1: Map &amp; Racial Demographics Let’s create the first tab! This tab features a map and a demographic chart, with controls for selecting demographic variables and neighborhoods. In this tab, we will include: - Demographic Variable Selection: Provides options related to economic conditions. - Interactive map and chart: Visualize the selected economic data spatially and through a bar chart. Here are the explanation for some functions that we used below: - selectInput for demographic variable: Allows users to select which demographic statistic to visualize on the map. - selectInput for neighborhood: Enables users to pick a specific neighborhood for detailed demographic breakdown in the chart. - leafletOutput and plotlyOutput: Reserved spaces in the UI for displaying the map and the chart respectively. tab1_ui &lt;- tabPanel(&quot;Map &amp; Racial Demographics&quot;, sidebarLayout( sidebarPanel( selectInput(&quot;color&quot;, &quot;Demographic variable:&quot;, choices = c(&quot;Percent Black&quot; = &quot;pctblack&quot;, &quot;Percent Hispanic&quot; = &quot;pcthisp&quot;, &quot;Percent White&quot; = &quot;pctwhite&quot;), selected = &quot;pctblack&quot;), selectInput(&quot;neighborhood&quot;, &quot;Select Neighborhood:&quot;, choices = nyc_data$NTAName, selected = &quot;Pelham Bay-Country Club-City Island&quot;), helpText(&quot;Data source: NYC Neighborhood Data&quot;) ), mainPanel( fluidRow( column(12, leafletOutput(&quot;map&quot;)), column(12, plotlyOutput(&quot;racialDemoChart&quot;)) ) ) ) ) B.3.5.2 Tab 2: Socioeconomic Demographics Similar in structure to Tab 1, now let’s create the Tab 2, which focuses on socioeconomic indicators such as poverty levels and rent burden. tab2_ui &lt;- tabPanel(&quot;Socioeconomic Demographics&quot;, sidebarLayout( sidebarPanel( selectInput(&quot;color_socio&quot;, &quot;Demographic variable:&quot;, choices = c(&quot;Percent in Poverty&quot; = &quot;pctpov&quot;, &quot;Rent &lt; 30% of Income&quot; = &quot;rent.30&quot;, &quot;Rent &lt; 50% of Income&quot; = &quot;rent.50&quot;), selected = &quot;pctpov&quot;), selectInput(&quot;neighborhood_socio&quot;, &quot;Select Neighborhood:&quot;, choices = nyc_data$NTAName, selected = &quot;Pelham Bay-Country Club-City Island&quot;), helpText(&quot;Data source: NYC Neighborhood Data&quot;) ), mainPanel( fluidRow( column(12, leafletOutput(&quot;map_socio&quot;)), column(12, plotlyOutput(&quot;socioDemoChart&quot;)) ) ) ) ) B.3.5.3 Tab 3: Severe Maternal Morbidity &amp; Preterm Birth Rates In Tab 3, we want to introduces more health-related variables, displaying a map and a scatter plot. tab3_ui &lt;- tabPanel(&quot;Severe Maternal Morbidity &amp; Preterm Birth Rates&quot;, sidebarLayout( sidebarPanel( selectInput(&quot;color_health&quot;, &quot;Health variable:&quot;, choices = c(&quot;Severe Maternal Morbidity Rate&quot; = &quot;smmrate&quot;, &quot;Preterm Birth Rate&quot; = &quot;ptbrate&quot;), selected = &quot;smmrate&quot;), helpText(&quot;Data source: NYC Neighborhood Data&quot;) ), mainPanel( fluidRow( column(12, leafletOutput(&quot;map_health&quot;)), column(12, plotlyOutput(&quot;healthScatterChart&quot;)) ) ) ) ) B.3.5.4 Tab 4: About Finally, we also want to include a Tab 4 that provides contextual information about the application, explaining its purpose and the data source. tab4_ui &lt;- tabPanel(&quot;About&quot;, h3(&quot;About This App&quot;), p(&quot;This application provides a visual representation of demographic and health data across New York City&#39;s neighborhoods.&quot;), p(&quot;Select different demographic and health variables from the dropdown menus to explore the data.&quot;), p(&quot;Data source: NYC Neighborhood Data, provided in GeoJSON format and visualized using Leaflet and Plotly in a Shiny application.&quot;) ) B.3.6 Step 3: Define Server Logic After define the user interface, we will move on to define the server logic. It processes user inputs from the UI and updates the outputs (maps and charts). It dynamically reacts to user interactions such as selecting a neighborhood or a demographic variable. B.3.6.1 Server Logic for Tab 1: Now, we will create server code to handle the dynamic visualization of racial demographics within New York City neighborhoods in Tab 1. It renders an interactive map and a bar chart based on user inputs, showing the distribution of different racial groups. The map highlights neighborhoods with varying demographic densities, while the bar chart provides detailed statistics for a selected neighborhood. tab1_server &lt;- function(input, output, session) { # Map output for Racial Demographics output$map &lt;- renderLeaflet({ map_data &lt;- st_transform(nyc_data, crs = 4326) valid_data &lt;- map_data[!is.na(map_data[[input$color]]), ] pal &lt;- colorQuantile(&quot;YlOrRd&quot;, valid_data[[input$color]], n = 5) leaflet(valid_data) %&gt;% addProviderTiles(providers$CartoDB.Positron) %&gt;% addPolygons( fillColor = ~pal(valid_data[[input$color]]), fillOpacity = 0.7, weight = 1, color = &quot;white&quot;, popup = ~paste(NTAName, &quot;&lt;br&gt;&quot;, paste(input$color, &quot;:&quot;, round(valid_data[[input$color]], 2), &quot;%&quot;)) ) %&gt;% setView(lng = -73.935242, lat = 40.730610, zoom = 10) }) # Racial Demographics chart output$racialDemoChart &lt;- renderPlotly({ chart_data &lt;- nyc_data[nyc_data$NTAName == input$neighborhood, ] # Extract data and remove &quot;geometry&quot; column racial_data &lt;- as.data.frame(chart_data) racial_data &lt;- racial_data[, -which(names(racial_data) == &quot;geometry&quot;)] racial_data &lt;- racial_data[, c(&quot;pctblack&quot;, &quot;pcthisp&quot;, &quot;pctwhite&quot;, &quot;pctapi&quot;, &quot;pctother&quot;)] racial_data &lt;- t(racial_data) racial_data &lt;- as.data.frame(racial_data) racial_data &lt;- cbind(Race = rownames(racial_data), Percentage = racial_data[, 1]) rownames(racial_data) &lt;- NULL plot_ly(data = as.data.frame(racial_data), x = ~Race, y = ~Percentage, type = &#39;bar&#39;, color = ~Race) %&gt;% layout(title = paste(&quot;Racial Demographics -&quot;, input$neighborhood), xaxis = list(title = &quot;Race&quot;), yaxis = list(title = &quot;Percentage&quot;, range = c(0, 100), tickvals = seq(0, 100, 20))) }) } The server functions for other tabs follow a similar structure but focus on different data attributes. So, let’s define the server logic for other three tabs. B.3.6.2 Server Logic for Tab 2: tab2_server &lt;- function(input, output, session) { # Map output for Socioeconomic Demographics output$map_socio &lt;- renderLeaflet({ map_data &lt;- st_transform(nyc_data, crs = 4326) valid_data &lt;- map_data[!is.na(map_data[[input$color_socio]]), ] pal &lt;- colorQuantile(&quot;YlOrRd&quot;, valid_data[[input$color_socio]], n = 5) leaflet(valid_data) %&gt;% addProviderTiles(providers$CartoDB.Positron) %&gt;% addPolygons( fillColor = ~pal(valid_data[[input$color_socio]]), fillOpacity = 0.7, weight = 1, color = &quot;white&quot;, popup = ~paste(NTAName, &quot;&lt;br&gt;&quot;, paste(input$color_socio, &quot;:&quot;, round(valid_data[[input$color_socio]], 2), &quot;%&quot;)) ) %&gt;% setView(lng = -73.935242, lat = 40.730610, zoom = 10) }) # Socioeconomic Demographics chart output$socioDemoChart &lt;- renderPlotly({ chart_data &lt;- nyc_data[nyc_data$NTAName == input$neighborhood_socio, ] # Extract data and remove &quot;geometry&quot; column socio_data &lt;- as.data.frame(chart_data) socio_data &lt;- socio_data[, -which(names(socio_data) == &quot;geometry&quot;)] socio_data &lt;- socio_data[, c(&quot;pctpov&quot;, &quot;rent.30&quot;, &quot;rent.50&quot;)] socio_data &lt;- t(socio_data) socio_data &lt;- as.data.frame(socio_data) socio_data &lt;- cbind(Category = rownames(socio_data), Percentage = socio_data[, 1]) rownames(socio_data) &lt;- NULL plot_ly(data = as.data.frame(socio_data), x = ~Category, y = ~Percentage, type = &#39;bar&#39;, color = ~Category) %&gt;% layout(title = paste(&quot;Socioeconomic Demographics -&quot;, input$neighborhood_socio), xaxis = list(title = &quot;Category&quot;), yaxis = list(title = &quot;Percentage&quot;, range = c(0, 100), tickvals = seq(0, 100, 20))) }) } B.3.6.3 Server Logic for Tab 3: tab3_server &lt;- function(input, output, session) { # Map output for Health Demographics output$map_health &lt;- renderLeaflet({ map_data &lt;- st_transform(nyc_data, crs = 4326) valid_data &lt;- map_data[!is.na(map_data[[input$color_health]]), ] pal &lt;- colorQuantile(&quot;YlOrRd&quot;, valid_data[[input$color_health]], n = 5) leaflet(valid_data) %&gt;% addProviderTiles(providers$CartoDB.Positron) %&gt;% addPolygons( fillColor = ~pal(valid_data[[input$color_health]]), fillOpacity = 0.7, weight = 1, color = &quot;white&quot;, popup = ~paste(NTAName, &quot;&lt;br&gt;&quot;, paste(input$color_health, &quot;:&quot;, round(valid_data[[input$color_health]], 2))) ) %&gt;% setView(lng = -73.935242, lat = 40.730610, zoom = 10) }) # Health Demographics scatter plot output$healthScatterChart &lt;- renderPlotly({ plot_ly(nyc_data, x = ~smmrate, y = ~ptbrate, text = ~NTAName, mode = &#39;markers&#39;) %&gt;% layout(title = &quot;Severe Maternal Morbidity vs Preterm Birth Rates&quot;, xaxis = list(title = &quot;Severe Maternal Morbidity Rate&quot;), yaxis = list(title = &quot;Preterm Birth Rate&quot;, range = c(0, 100))) }) } Now, combine all tabs into a single UI object. ui &lt;- fluidPage( titlePanel(&quot;NYC Neighborhood Demographics&quot;), tabsetPanel( tab1_ui, tab2_ui, tab3_ui, tab4_ui ) ) B.3.7 Step 4: Run the Application In this final step,we combine the server logic for all tabs and define the overall UI layout to launch the application. # Combine server logic for all tabs server &lt;- function(input, output, session) { tab1_server(input, output, session) tab2_server(input, output, session) tab3_server(input, output, session) } # Run the application shinyApp(ui = ui, server = server) B.4 Conclusion This Shiny application offers a detailed and interactive exploration of demographic data across New York City neighborhoods. Users can interactively analyze racial and socioeconomic information through dynamically updated maps and charts. The application exemplifies how R and Shiny can be used to build engaging and informative data visualizations. Tutorials for R If you are new to R, we recommend the following intro-level tutorials provided through installation guides. You can also refer to this R for Social Scientists tutorial developed by Data Carpentry for a refresher. You can also visit the RStudio Education page to select a learning path tailored to your experience level (Beginners, Intermediates, Experts). They offer detailed instructions to learners at different stages of their R journey. "]]
