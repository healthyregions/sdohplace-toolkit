[["04-dataR.html", "A Data Wrangling in R A.1 Environmental Setup A.2 Intro to Spatial Data A.3 Converting to Spatial Data A.4 Merge Datasets A.5 Inspect Data A.6 Finding Data Resources", " A Data Wrangling in R Objectives In this module, you will: Introduction to spatial data concepts and operations Convert CSV lat/long to spatial points and geocode address Overlay points with boundary data, merge SDOH data, visualize as choropleth ** Add intro to R tips, resources (a short paragraph) A.1 Environmental Setup Before starting operations related to spatial data, we need to complete an environmental setup. A basic understanding of R is assumed. This workshop requires several packages, which can be installed from CRAN: install.packages(&quot;sf&quot;, &quot;tmap&quot;, &quot;tidygeocoder&quot;, &quot;dplyr&quot;, &quot;ggplot2&quot;) For Mac users, check out https://github.com/r-spatial/sf for additional tips if you run into errors when installing the sf package. Using homebrew to install gdal usually fixes any remaining issues. Now, loading the required libraries for further steps: library(sf) ## Linking to GEOS 3.11.0, GDAL 3.5.3, PROJ 9.1.0; sf_use_s2() is TRUE library(dplyr) ## ## Attaching package: &#39;dplyr&#39; ## The following objects are masked from &#39;package:stats&#39;: ## ## filter, lag ## The following objects are masked from &#39;package:base&#39;: ## ## intersect, setdiff, setequal, union library(ggplot2) A.2 Intro to Spatial Data Spatial data is essential for understanding the world around us, as it combines information with specific locations. This type of data is vital because it allows us to see how information changes with location. Without the geographical component, we’re left with just a list, not a map that can guide decisions or provide insights. An important concept within spatial data is “simple features,” which is an international standard for how we represent real-world objects and their shapes on computers. This standard is the backbone of many Geographic Information Systems (GIS) technologies, making it easier for us to map and analyze spatial data. For example, in the R programming environment, spatial objects can be stored in a way that’s easy to work with, integrating seamlessly with other data analysis processes. Understanding these aspects of spatial data is crucial, especially as we delve into more complex analyses. Whether it’s navigating through the components of a shapefile or exploring data in R, having a grasp on these concepts can help tackle the challenges that come with spatial data analysis. Load Spatial Data We need to load the spatial data (shapefile). All the data used for this one assignment can be found here here. Remember, this type of data is actually comprised of multiple files. All need to be present in order to read correctly. Chi_tracts = st_read(&quot;o4rtestdata/geo_export_aae47441-adab-4aca-8cb0-2e0c0114096e.shp&quot;) ## Reading layer `geo_export_aae47441-adab-4aca-8cb0-2e0c0114096e&#39; from data source `/Users/yilinlyu/Documents/sdohplace-toolkit/o4rtestdata/geo_export_aae47441-adab-4aca-8cb0-2e0c0114096e.shp&#39; ## using driver `ESRI Shapefile&#39; ## Simple feature collection with 801 features and 9 fields ## Geometry type: POLYGON ## Dimension: XY ## Bounding box: xmin: -87.94025 ymin: 41.64429 xmax: -87.52366 ymax: 42.02392 ## Geodetic CRS: WGS84(DD) Always inspect data when loading in. First we look at a non-spatial view. head(Chi_tracts) ## Simple feature collection with 6 features and 9 fields ## Geometry type: POLYGON ## Dimension: XY ## Bounding box: xmin: -87.68822 ymin: 41.72902 xmax: -87.62394 ymax: 41.87455 ## Geodetic CRS: WGS84(DD) ## commarea commarea_n countyfp10 geoid10 name10 namelsad10 notes ## 1 44 44 031 17031842400 8424 Census Tract 8424 &lt;NA&gt; ## 2 59 59 031 17031840300 8403 Census Tract 8403 &lt;NA&gt; ## 3 34 34 031 17031841100 8411 Census Tract 8411 &lt;NA&gt; ## 4 31 31 031 17031841200 8412 Census Tract 8412 &lt;NA&gt; ## 5 32 32 031 17031839000 8390 Census Tract 8390 &lt;NA&gt; ## 6 28 28 031 17031838200 8382 Census Tract 8382 &lt;NA&gt; ## statefp10 tractce10 geometry ## 1 17 842400 POLYGON ((-87.62405 41.7302... ## 2 17 840300 POLYGON ((-87.68608 41.8229... ## 3 17 841100 POLYGON ((-87.62935 41.8528... ## 4 17 841200 POLYGON ((-87.68813 41.8556... ## 5 17 839000 POLYGON ((-87.63312 41.8744... ## 6 17 838200 POLYGON ((-87.66782 41.8741... Note the last column – this is a spatially enabled column. The data is no longer a ‘shapefile’ but an `sf’ object, comprised of polygons. We can use a baseR function to view the spatial dimension. The sf framework enables previews of each attribute in our spatial file. plot(Chi_tracts) Check out the data structure of this file. str(Chi_tracts) ## Classes &#39;sf&#39; and &#39;data.frame&#39;: 801 obs. of 10 variables: ## $ commarea : chr &quot;44&quot; &quot;59&quot; &quot;34&quot; &quot;31&quot; ... ## $ commarea_n: num 44 59 34 31 32 28 65 53 76 77 ... ## $ countyfp10: chr &quot;031&quot; &quot;031&quot; &quot;031&quot; &quot;031&quot; ... ## $ geoid10 : chr &quot;17031842400&quot; &quot;17031840300&quot; &quot;17031841100&quot; &quot;17031841200&quot; ... ## $ name10 : chr &quot;8424&quot; &quot;8403&quot; &quot;8411&quot; &quot;8412&quot; ... ## $ namelsad10: chr &quot;Census Tract 8424&quot; &quot;Census Tract 8403&quot; &quot;Census Tract 8411&quot; &quot;Census Tract 8412&quot; ... ## $ notes : chr NA NA NA NA ... ## $ statefp10 : chr &quot;17&quot; &quot;17&quot; &quot;17&quot; &quot;17&quot; ... ## $ tractce10 : chr &quot;842400&quot; &quot;840300&quot; &quot;841100&quot; &quot;841200&quot; ... ## $ geometry :sfc_POLYGON of length 801; first list element: List of 1 ## ..$ : num [1:243, 1:2] -87.6 -87.6 -87.6 -87.6 -87.6 ... ## ..- attr(*, &quot;class&quot;)= chr [1:3] &quot;XY&quot; &quot;POLYGON&quot; &quot;sfg&quot; ## - attr(*, &quot;sf_column&quot;)= chr &quot;geometry&quot; ## - attr(*, &quot;agr&quot;)= Factor w/ 3 levels &quot;constant&quot;,&quot;aggregate&quot;,..: NA NA NA NA NA NA NA NA NA ## ..- attr(*, &quot;names&quot;)= chr [1:9] &quot;commarea&quot; &quot;commarea_n&quot; &quot;countyfp10&quot; &quot;geoid10&quot; ... Coordinate Reference Systems The Earth is an irregular ellipsoid, rather than a perfect sphere. As a result, many ways of visualizing the Earth, in whole or in part, have been developed. A Coordinate Reference System (CRS) communicates what method should be used to flatten or project the Earth’s surface onto a 2-dimensional map. Different CRS imply different ways of projections and can generate substantially different visualizations. For example, the following are some world maps using different projections: pic from slide 13 intro2spatialmed In addition to projections that optimize for global accuracy, there are many regional projections. For instance, NAD83 (North American Datum 1983) is divided into several UTM (universal transverse mercator) zones across the continent. So when projecting a dataset of Illinois, for example, the most appropriate NAD83 projection would be NAD83 UTM zone 16N. Projection names have also been standardized to EPSG codes. The projection NAD83 UTM zone 16N is EPSG:26916. Many datasets available online, and GeoJSON files as a general rule, default to the projection EPSG:4326, a global projection used by GPS. Changing projections can be critical for improving accuracy for your project, and making sure your layers are being displayed using the same information. Always search the internet to determine what projection is most appropriate for your project, and to find the corresponding EPSG code. For this exercise we will explore how to change the projection of a spatial dataset in R. First, check out the coordinate reference system. st_crs(Chi_tracts) ## Coordinate Reference System: ## User input: WGS84(DD) ## wkt: ## GEOGCRS[&quot;WGS84(DD)&quot;, ## DATUM[&quot;WGS84&quot;, ## ELLIPSOID[&quot;WGS84&quot;,6378137,298.257223563, ## LENGTHUNIT[&quot;metre&quot;,1, ## ID[&quot;EPSG&quot;,9001]]]], ## PRIMEM[&quot;Greenwich&quot;,0, ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]], ## CS[ellipsoidal,2], ## AXIS[&quot;geodetic longitude&quot;,east, ## ORDER[1], ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]], ## AXIS[&quot;geodetic latitude&quot;,north, ## ORDER[2], ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]]] To transform our CRS, we use the st_transform function. Let’s choose a projection that is focused on Illinois, and uses distance as feet or meters, to make it a bit more accessible for our work. EPSG:3435 is a good fit: Chi_tracts.3435 &lt;- st_transform(Chi_tracts, &quot;EPSG:3435&quot;) # Chi_tracts.3435 &lt;- st_transform(Chi_tracts, 3435) st_crs(Chi_tracts.3435) ## Coordinate Reference System: ## User input: EPSG:3435 ## wkt: ## PROJCRS[&quot;NAD83 / Illinois East (ftUS)&quot;, ## BASEGEOGCRS[&quot;NAD83&quot;, ## DATUM[&quot;North American Datum 1983&quot;, ## ELLIPSOID[&quot;GRS 1980&quot;,6378137,298.257222101, ## LENGTHUNIT[&quot;metre&quot;,1]]], ## PRIMEM[&quot;Greenwich&quot;,0, ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]], ## ID[&quot;EPSG&quot;,4269]], ## CONVERSION[&quot;SPCS83 Illinois East zone (US Survey feet)&quot;, ## METHOD[&quot;Transverse Mercator&quot;, ## ID[&quot;EPSG&quot;,9807]], ## PARAMETER[&quot;Latitude of natural origin&quot;,36.6666666666667, ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433], ## ID[&quot;EPSG&quot;,8801]], ## PARAMETER[&quot;Longitude of natural origin&quot;,-88.3333333333333, ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433], ## ID[&quot;EPSG&quot;,8802]], ## PARAMETER[&quot;Scale factor at natural origin&quot;,0.999975, ## SCALEUNIT[&quot;unity&quot;,1], ## ID[&quot;EPSG&quot;,8805]], ## PARAMETER[&quot;False easting&quot;,984250, ## LENGTHUNIT[&quot;US survey foot&quot;,0.304800609601219], ## ID[&quot;EPSG&quot;,8806]], ## PARAMETER[&quot;False northing&quot;,0, ## LENGTHUNIT[&quot;US survey foot&quot;,0.304800609601219], ## ID[&quot;EPSG&quot;,8807]]], ## CS[Cartesian,2], ## AXIS[&quot;easting (X)&quot;,east, ## ORDER[1], ## LENGTHUNIT[&quot;US survey foot&quot;,0.304800609601219]], ## AXIS[&quot;northing (Y)&quot;,north, ## ORDER[2], ## LENGTHUNIT[&quot;US survey foot&quot;,0.304800609601219]], ## USAGE[ ## SCOPE[&quot;Engineering survey, topographic mapping.&quot;], ## AREA[&quot;United States (USA) - Illinois - counties of Boone; Champaign; Clark; Clay; Coles; Cook; Crawford; Cumberland; De Kalb; De Witt; Douglas; Du Page; Edgar; Edwards; Effingham; Fayette; Ford; Franklin; Gallatin; Grundy; Hamilton; Hardin; Iroquois; Jasper; Jefferson; Johnson; Kane; Kankakee; Kendall; La Salle; Lake; Lawrence; Livingston; Macon; Marion; Massac; McHenry; McLean; Moultrie; Piatt; Pope; Richland; Saline; Shelby; Vermilion; Wabash; Wayne; White; Will; Williamson.&quot;], ## BBOX[37.06,-89.28,42.5,-87.02]], ## ID[&quot;EPSG&quot;,3435]] plot(st_geometry(Chi_tracts.3435), border = &quot;gray&quot;, lwd = 2, main = &quot;NAD83 / Illinois East (ftUS)&quot;, sub=&quot;topo mapping &amp; survey use&quot;) Refine Basic Map Now we’ll switch to a more extensive cartographic mapping package, tmap. We approach mapping with one layer at a time. Always start with the object you want to map by calling it with the tm_shape function. Then, at least one descriptive/styling function follows. There are hundreds of variations and paramater specifications, so take your time in exploring tmap and the options. Here we style the tracts with some semi-transparent borders. library(tmap) ## Breaking News: tmap 3.x is retiring. Please test v4, e.g. with ## remotes::install_github(&#39;r-tmap/tmap&#39;) tm_shape(Chi_tracts) + tm_borders(alpha=0.5) Next we fill the tracts with a light gray, and adjust the color and transparency of borders. We also add a scale bar, positioning it to the left and having a thickness of 0.8 units, and turn off the frame. tm_shape(Chi_tracts) + tm_fill(col = &quot;gray90&quot;) + tm_borders(alpha=0.2, col = &quot;gray10&quot;) + tm_scale_bar(position = (&quot;left&quot;), lwd = 0.8) + tm_layout(frame = F) Check out https://rdrr.io/cran/tmap/man/tm_polygons.html for more ideas! A.3 Converting to Spatial Data A common goal in SDOH research is to work address-level data, known as points or events (when considering time) in spatial analysis research. This could refer to resources in a community, . Before we can run any analytics on the resource location data, we need to convert resource addresses to spatial data points, which can be then used to calculate access metrics. Locations, when measured as points, can include things like: Health providers: Hospitals, Clinics, Pharmacies, Mental health providers, Medication for opioid use disorder providers Area resources: Grocery stores &amp; Supermarkets, Playgrounds, Daycare centers, Schools, Community centers Area challenges: Crime, Superfund sites, Pollution-emitting facilities Points can also represent people, like individual patients residing in an area. Because individual locations for persons is protected health information, we’ll focus on point data as resources in the chapter. However, you can reuse the approach in this workshop to wrangle patient-level data the same way in a secure environment, under the guidance of your friendly IRB ethics board. Let’s start with an example where the spatial coordinate information has already been embedded within the data set as latitude and longitude information. A.3.1 Convert CSVs to Spatial Data Converting CSV latitude and longitude data to points in R is a straightforward yet powerful method for spatial analysis. This process involves using the sf package to transform geographic coordinates into spatial points, allowing for easy mapping and analysis. It’s an essential step for anyone working with geospatial data, enabling the visualization of locations and the application of geographic information systems (GIS) techniques. By assigning a Coordinate Reference System (CRS), these points become ready for spatial operations. We are using the “Affordable_Rental_Housing_Developments.csv” in the dataset to show how to convert a csv Lat/Long data to points. First, we need to load the CSV data: housing = read.csv(&quot;o4rtestdata/Affordable_Rental_Housing_Developments.csv&quot;) Then, we need to ensure that no column (intended to be used as a coordinate) is entirely empty or filled with NA values: cleaned_housing &lt;- na.omit(housing) Finally, we start to convert it to points: points_housing &lt;- st_as_sf(cleaned_housing, coords = c(&quot;Longitude&quot;, &quot;Latitude&quot;), crs = 3435) If you want, you can view the resulting sf object: print(points_housing) ## Simple feature collection with 487 features and 12 fields ## Geometry type: POINT ## Dimension: XY ## Bounding box: xmin: -87.80707 ymin: 41.64846 xmax: -87.54012 ymax: 42.01715 ## Projected CRS: NAD83 / Illinois East (ftUS) ## First 10 features: ## Community.Area.Name Community.Area.Number Property.Type ## 2 Rogers Park 1 Senior ## 3 Uptown 3 ARO ## 4 Edgewater 77 Senior ## 5 Roseland 49 Supportive Housing ## 6 Humboldt Park 23 Multifamily ## 7 Grand Boulevard 38 Multifamily ## 8 Woodlawn 42 Multifamily ## 9 Oakland 36 Multifamily ## 10 Oakland 36 Senior ## 11 Near North Side 8 Supportive Housing ## Property.Name Address ## 2 Morse Senior Apts. 6928 N. Wayne Ave. ## 3 The Draper 5050 N. Broadway ## 4 Pomeroy Apts. 5650 N. Kenmore Ave. ## 5 Wentworth Commons 11045 S. Wentworth Ave. ## 6 Nelson Mandela Apts. 607 N. Sawyer Ave. ## 7 Legends South - Gwendolyn Place 4333 S. Michigan Ave. ## 8 Dorchester Apts. 1410 E. 62nd St. ## 9 Oakwood Shrs 1A, 1B, 2A, 2B1 (scattered sites) 3859 S. Vincennes Ave. ## 10 Oakwood Shores Terrace 3755 S. Cottage Grove Ave. ## 11 The Midwest/Carroll Park Apts. 1333 N. Kingsbury St. ## Zip.Code Phone.Number Management.Company Units X.Coordinate ## 2 60626 312-602-6207 Morse Urban Dev. 44 1165844 ## 3 60640 312-818-1722 Flats LLC 35 1167357 ## 4 60660 773-275-7820 Habitat Company 198 1168181 ## 5 60628 773-568-7804 Mercy Housing Lakefront 50 1176951 ## 6 60624 773-227-6332 Bickerdike Apts. 6 1154640 ## 7 60653 773-624-7676 Interstate Realty Management Co. 71 1177924 ## 8 60637 773-572-5500 The Thresholds 67 1186722 ## 9 60653 773-373-1300 The Community Builders 534 1180730 ## 10 60653 773-373-1300 The Community Builders, Inc. 148 1181956 ## 11 60622 312-337-5339 Holsten Real Estate Dev. Corp. 40 1170359 ## Y.Coordinate Location ## 2 1946059 (42.0075737709331, -87.6651711448293) ## 3 1933882 (41.9741295261027, -87.6599553011627) ## 4 1937918 (41.9851867755403, -87.656808676983) ## 5 1831516 (41.6930159120977, -87.6277673462214) ## 6 1903912 (41.8921534052465, -87.7075265659001) ## 7 1876178 (41.815550396096, -87.6228565224104) ## 8 1864210 (41.782505219358, -87.5909616432556) ## 9 1879251 (41.8239192006736, -87.6124684434156) ## 10 1880135 (41.8263173139507, -87.6079454471381) ## 11 1908980 (41.9057310022859, -87.6496459663701) ## geometry ## 2 POINT (-87.66517 42.00757) ## 3 POINT (-87.65996 41.97413) ## 4 POINT (-87.65681 41.98519) ## 5 POINT (-87.62777 41.69302) ## 6 POINT (-87.70753 41.89215) ## 7 POINT (-87.62286 41.81555) ## 8 POINT (-87.59096 41.78251) ## 9 POINT (-87.61247 41.82392) ## 10 POINT (-87.60795 41.82632) ## 11 POINT (-87.64965 41.90573) A.3.2 Geocode Addresses If you start with only addresses, you’ll need to geocode! Addresses are not spatial data. They are real-world representations of spatial data, but GIS software will not be able to map them without further information. Geocoding is the process of converting addresses into geographic coordinates using a known coordinate reference system (CRS). We can then use these coordinates (ex. longitude, latitude) to spatially enable data. Explain that there are multiple geocoding services available, with varying quality. How precise does your measure need to be? Do you want to reject matches with &lt;90% uncertainty? If you’re at a university or public sector setting, you may have access to ESRI geocoding services… Also note how you should NEVER geocode sensitive data as it’s not HIPPA protected unless on a compliant server… After determining the service, plan for data cleaning/preparation stage, matching goals ** redo following section as tool-neutral tips : Geocoding tools may be having an issue reading some addresses due to formatting issues in the CSV. Suite or apartment numbers, for example, may cause tools to be unable to geocode addresses. Only include the street address in the address column of your CSV. If you want to retain apartment or suite numbers, include them in a separate column in your CSV. Another common issue is an address being miswritten in your CSV file. Even something as small as an extra apostrophe can prevent an address from being geocoded properly. Many cities have also addresses that are duplicates or are very similar. Providing the most information you can is the best way to resolve this issue. Geocoding tools can use street address, city, state, and country information to geocode addresses. If you do not already have all of this information in your original CSV, add it and try geocoding again. First we load the tidygeocoder to get our geocoding done. Note, this uses the interent to process, so is not suitable for HIPPA protected data like individual, living person addresses. For offline geocoders, check out Pelias or ESRI. library(tidygeocoder) Let’s read in and inspect data for methadone maintenance providers. Note, these addresses were made available by SAMSHA, and are known as publicly available information. An additional analysis could call each service to check on access to medication during COVID in Septmber 2020, and the list would be updated further. methadoneClinics &lt;- read.csv(&quot;o4rtestdata/chicago_methadone_nogeometry.csv&quot;) head(methadoneClinics) ## X Name ## 1 1 Chicago Treatment and Counseling Center, Inc. ## 2 2 Sundace Methadone Treatment Center, LLC ## 3 3 Soft Landing Interventions/DBA Symetria Recovery of Lakeview ## 4 4 PDSSC - Chicago, Inc. ## 5 5 Center for Addictive Problems, Inc. ## 6 6 Family Guidance Centers, Inc. ## Address City State Zip ## 1 4453 North Broadway st. Chicago IL 60640 ## 2 4545 North Broadway St. Chicago IL 60640 ## 3 3934 N. Lincoln Ave. Chicago IL 60613 ## 4 2260 N. Elston Ave. Chicago IL 60614 ## 5 609 N. Wells St. Chicago IL 60654 ## 6 310 W. Chicago Ave. Chicago IL 60654 Let’s geocode one address first, just to make sure our system is working. We’ll use the “cascade” method which use the US Census and OpenStreetMap geocoders. These two services are the main options with tidygeocoder. sample &lt;- geo(&quot;2260 N. Elston Ave. Chicago, IL&quot;, lat = latitude, long = longitude, method = &#39;cascade&#39;) ## Warning: The `method` argument of `geo()` cannot be &quot;cascade&quot; as of tidygeocoder 1.0.4. ## ℹ Please use `geocode_combine()` instead. ## This warning is displayed once every 8 hours. ## Call `lifecycle::last_lifecycle_warnings()` to see where this warning was ## generated. ## Passing 1 address to the US Census single address geocoder ## Query completed in: 0.6 seconds head(sample) ## # A tibble: 1 × 4 ## address latitude longitude geo_method ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 2260 N. Elston Ave. Chicago, IL 41.9 -87.7 census As we prepare for geocoding, check out the structure of the dataset. The data should be a character to be read properly. str(methadoneClinics) ## &#39;data.frame&#39;: 27 obs. of 6 variables: ## $ X : int 1 2 3 4 5 6 7 8 9 10 ... ## $ Name : chr &quot;Chicago Treatment and Counseling Center, Inc.&quot; &quot;Sundace Methadone Treatment Center, LLC&quot; &quot;Soft Landing Interventions/DBA Symetria Recovery of Lakeview&quot; &quot;PDSSC - Chicago, Inc.&quot; ... ## $ Address: chr &quot;4453 North Broadway st.&quot; &quot;4545 North Broadway St.&quot; &quot;3934 N. Lincoln Ave.&quot; &quot;2260 N. Elston Ave.&quot; ... ## $ City : chr &quot;Chicago&quot; &quot;Chicago&quot; &quot;Chicago&quot; &quot;Chicago&quot; ... ## $ State : chr &quot;IL&quot; &quot;IL&quot; &quot;IL&quot; &quot;IL&quot; ... ## $ Zip : int 60640 60640 60613 60614 60654 60654 60651 60607 60607 60616 ... We need to clean the data a bit. We’ll add a new column for a full address, as required by the geocoding service. When you use a geocoding service, be sure to read the documentation and understand how the data needs to be formatted for input. methadoneClinics$fullAdd &lt;- paste(as.character(methadoneClinics$Address), as.character(methadoneClinics$City), as.character(methadoneClinics$State), as.character(methadoneClinics$Zip)) We’re ready to go! Batch geocode with one function, and inspect: geoCodedClinics &lt;- geocode(methadoneClinics, address = &#39;fullAdd&#39;, lat = latitude, long = longitude, method = &#39;cascade&#39;) ## Passing 27 addresses to the US Census batch geocoder ## Query completed in: 0.4 seconds head(geoCodedClinics) ## # A tibble: 6 × 10 ## X Name Address City State Zip fullAdd latitude longitude geo_method ## &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 1 Chicago… 4453 N… Chic… IL 60640 4453 N… 42.0 -87.7 census ## 2 2 Sundace… 4545 N… Chic… IL 60640 4545 N… 42.0 -87.7 census ## 3 3 Soft La… 3934 N… Chic… IL 60613 3934 N… 42.0 -87.7 census ## 4 4 PDSSC -… 2260 N… Chic… IL 60614 2260 N… 41.9 -87.7 census ## 5 5 Center … 609 N.… Chic… IL 60654 609 N.… 41.9 -87.6 census ## 6 6 Family … 310 W.… Chic… IL 60654 310 W.… 41.9 -87.6 census There were two that didn’t geocode correctly. You can inspect further. This could involve a quick check for spelling issues; or, searching the address and pulling the lat/long using Google Maps and inputting manually. Or, if we are concerned it’s a human or unknown error, we could omit. For this exercise we’ll just omit the two clinics that didn’t geocode correctly. geoCodedClinics2 &lt;- na.omit(geoCodedClinics) Convert to Spatial Data This is not spatial data yet! To convert a static file to spatial data, we use the powerful st_as_sf function from sf. Indicate the x,y parameters (=longitude, latitude) and the coordinate reference system used. Our geocoding service used the standard EPSG:4326, so we input that here. library(sf) methadoneSf &lt;- st_as_sf(geoCodedClinics2, coords = c( &quot;longitude&quot;, &quot;latitude&quot;), crs = 4326) Basic Map of Points For a really simple map of points – to ensure they were geocoded and converted to spatial data correctly, we use tmap. We’ll use the interactive version to view. library(tmap) tmap_mode(&quot;view&quot;) tm_shape(methadoneSf) + tm_dots() If your points didn’t plot correctly: Did you flip the longitude/latitude values? Did you input the correct CRS? Those two issues are the most common errors. A.4 Merge Datasets Merging data sets is a vital skill for analyzing health data from an SDOH perspective. SDOH data and health data will often be in separate data sets, but use the same geographic scale, such as zip code or census tract. Being able to merge these kinds of data sets together using that scale is important to the ease of performing analysis with your data. Reshape Data Datasets often don’t come in GIS-friendly formats. Data may be separated vertically among multiple variables rather than horizontally along a single identifying variable. To merge data to boundaries, we’ll have to reshape from long to wide format. Long data formats have repeating values in the first column, compared to wide data formats which do not. Long formats are preferred in epidemiology work, but wide formats are needed for spatial data, making conversions between the two especially important in the realm of health geography. – explain long vs wide data formats – long preferred in epi work – wide formats needed to spatial data Here, we are trying to use the COVID-19_Cases__Tests__and_Deaths_by_ZIP_Code.csv dataset to practice how to convert long data to a wide data format. covid = read.csv(&quot;o4rtestdata/COVID-19_Cases__Tests__and_Deaths_by_ZIP_Code.csv&quot;) covid_clean = covid[,c(1:2, 6)] head(covid_clean, 3) ## ZIP.Code Week.Number Cases...Cumulative ## 1 60603 39 13 ## 2 60604 39 31 ## 3 60611 16 72 Now, we are trying to create a wide data set with the cumulative cases for each week for each zip code. Enter the code and you will see the new wide data format. covid_wide &lt;- reshape(covid_clean, direction = &quot;wide&quot;, idvar = &quot;ZIP.Code&quot;, timevar = &quot;Week.Number&quot;) head(covid_wide, 3) ## ZIP.Code Cases...Cumulative.39 Cases...Cumulative.16 Cases...Cumulative.15 ## 1 60603 13 NA NA ## 2 60604 31 NA NA ## 3 60611 458 72 64 ## Cases...Cumulative.11 Cases...Cumulative.10 Cases...Cumulative.12 ## 1 NA NA NA ## 2 NA NA NA ## 3 NA NA 16 ## Cases...Cumulative.13 Cases...Cumulative.14 Cases...Cumulative.34 ## 1 NA NA 11 ## 2 NA NA 29 ## 3 41 57 352 ## Cases...Cumulative.17 Cases...Cumulative.18 Cases...Cumulative.19 ## 1 NA NA NA ## 2 6 11 14 ## 3 80 92 99 ## Cases...Cumulative.20 Cases...Cumulative.31 Cases...Cumulative.22 ## 1 5 9 6 ## 2 17 25 22 ## 3 114 286 139 ## Cases...Cumulative.23 Cases...Cumulative.24 Cases...Cumulative.25 ## 1 6 6 6 ## 2 23 24 24 ## 3 148 152 163 ## Cases...Cumulative.28 Cases...Cumulative.29 Cases...Cumulative.30 ## 1 6 8 9 ## 2 25 25 25 ## 3 223 240 264 ## Cases...Cumulative.32 Cases...Cumulative.33 Cases...Cumulative.26 ## 1 10 11 6 ## 2 25 25 25 ## 3 305 333 175 ## Cases...Cumulative.27 Cases...Cumulative.36 Cases...Cumulative.38 ## 1 6 11 13 ## 2 25 31 31 ## 3 196 391 435 ## Cases...Cumulative.21 Cases...Cumulative.35 Cases...Cumulative.37 ## 1 6 11 13 ## 2 20 30 31 ## 3 124 371 411 ## Cases...Cumulative.40 ## 1 14 ## 2 31 ## 3 478 Join by Attribute ** Merge SDOH Data to Boundary Dataset From here, we can integrate more data. Let’s try a different point dataset – Affordable Rental Housing Developments, as made available by the City of Chicago Data Portal. This could be interesting for a number of different reasons – maybe we hypothesize better outcomes are associated with better access to affordable housing options? Or, we hypothesize the opposite, that mean distance to more population dense housing locations is vulnerable to airborne disease? For this example, we’ll think about this dataset as access to secure and affordable housing. Persons with lower incomes residing in places with fewer developments may be more vulnerable to housing insecurity -&gt; impacts health. AffHousing &lt;- read.csv(&quot;o4rtestdata/Affordable_Rental_Housing_Developments.csv&quot;) head(AffHousing) ## Community.Area.Name Community.Area.Number Property.Type ## 1 Englewood 68 Veterans ## 2 Rogers Park 1 Senior ## 3 Uptown 3 ARO ## 4 Edgewater 77 Senior ## 5 Roseland 49 Supportive Housing ## 6 Humboldt Park 23 Multifamily ## Property.Name Address Zip.Code Phone.Number ## 1 Hope Manor Village 5900-6100 S. Green/Peoria/Sangamon 60621 312-564-2393 ## 2 Morse Senior Apts. 6928 N. Wayne Ave. 60626 312-602-6207 ## 3 The Draper 5050 N. Broadway 60640 312-818-1722 ## 4 Pomeroy Apts. 5650 N. Kenmore Ave. 60660 773-275-7820 ## 5 Wentworth Commons 11045 S. Wentworth Ave. 60628 773-568-7804 ## 6 Nelson Mandela Apts. 607 N. Sawyer Ave. 60624 773-227-6332 ## Management.Company Units X.Coordinate Y.Coordinate Latitude ## 1 Volunteers of America Illinois 36 NA NA NA ## 2 Morse Urban Dev. 44 1165844 1946059 42.00757 ## 3 Flats LLC 35 1167357 1933882 41.97413 ## 4 Habitat Company 198 1168181 1937918 41.98519 ## 5 Mercy Housing Lakefront 50 1176951 1831516 41.69302 ## 6 Bickerdike Apts. 6 1154640 1903912 41.89215 ## Longitude Location ## 1 NA ## 2 -87.66517 (42.0075737709331, -87.6651711448293) ## 3 -87.65996 (41.9741295261027, -87.6599553011627) ## 4 -87.65681 (41.9851867755403, -87.656808676983) ## 5 -87.62777 (41.6930159120977, -87.6277673462214) ## 6 -87.70753 (41.8921534052465, -87.7075265659001) There were a few data points with odd inputs and null values. Remember, we can’t convert any null values to spatial coordinates. Again, in an ideal context, you would explore and understand what is happening, systematically. In our experiment, we’ll omit nulls. AffHousing &lt;- na.omit(AffHousing) Look at the structure of the object. str(AffHousing) ## &#39;data.frame&#39;: 487 obs. of 14 variables: ## $ Community.Area.Name : chr &quot;Rogers Park&quot; &quot;Uptown&quot; &quot;Edgewater&quot; &quot;Roseland&quot; ... ## $ Community.Area.Number: int 1 3 77 49 23 38 42 36 36 8 ... ## $ Property.Type : chr &quot;Senior&quot; &quot;ARO&quot; &quot;Senior&quot; &quot;Supportive Housing&quot; ... ## $ Property.Name : chr &quot;Morse Senior Apts.&quot; &quot;The Draper&quot; &quot;Pomeroy Apts.&quot; &quot;Wentworth Commons&quot; ... ## $ Address : chr &quot;6928 N. Wayne Ave.&quot; &quot;5050 N. Broadway&quot; &quot;5650 N. Kenmore Ave.&quot; &quot;11045 S. Wentworth Ave.&quot; ... ## $ Zip.Code : int 60626 60640 60660 60628 60624 60653 60637 60653 60653 60622 ... ## $ Phone.Number : chr &quot;312-602-6207&quot; &quot;312-818-1722&quot; &quot;773-275-7820&quot; &quot;773-568-7804&quot; ... ## $ Management.Company : chr &quot;Morse Urban Dev.&quot; &quot;Flats LLC&quot; &quot;Habitat Company&quot; &quot;Mercy Housing Lakefront&quot; ... ## $ Units : int 44 35 198 50 6 71 67 534 148 40 ... ## $ X.Coordinate : num 1165844 1167357 1168181 1176951 1154640 ... ## $ Y.Coordinate : num 1946059 1933882 1937918 1831516 1903912 ... ## $ Latitude : num 42 42 42 41.7 41.9 ... ## $ Longitude : num -87.7 -87.7 -87.7 -87.6 -87.7 ... ## $ Location : chr &quot;(42.0075737709331, -87.6651711448293)&quot; &quot;(41.9741295261027, -87.6599553011627)&quot; &quot;(41.9851867755403, -87.656808676983)&quot; &quot;(41.6930159120977, -87.6277673462214)&quot; ... ## - attr(*, &quot;na.action&quot;)= &#39;omit&#39; Named int 1 ## ..- attr(*, &quot;names&quot;)= chr &quot;1&quot; In this dataset, we can see coordinate information is already included – twice! You’re looking at 2 different types of coordinate systems. We’ll use “Longitude” and “Latitude” to represent X,Y and an ESPG of 4326. We’re guessing, and hopeful. AffHousingSf &lt;- st_as_sf(AffHousing, coords = c(&quot;Longitude&quot;, &quot;Latitude&quot;), crs = 4326) We can the size of the point, according to some attribute of the data. In this dataset, we see an attribute field that gives us the total number of units per housing site. Let’s use a graduated symbology, with the tm_bubbles() function, to map these points. That way points with more units will be bigger, and not all places are weighted the same visually. We can now map the data for a quick view – does this look like Chicago, hopefully? tm_shape(AffHousingSf) + tm_bubbles(&quot;Units&quot;, col = &quot;purple&quot;, style = &quot;sd&quot;) ## Legend for symbol sizes not available in view mode. Join by Location We’ll create a spatial join with affordable housing development data and ChiZipMaster1.geojson. In this case, we’ll add the number of affordable housing developments in each zip code to the zip code data set. housing = read.csv(&quot;o4rtestdata/Affordable_Rental_Housing_Developments.csv&quot;) zipcode &lt;- st_read(&quot;o4rtestdata/ChiZipMaster1.geojson&quot;) ## Reading layer `ChiZipMaster1&#39; from data source ## `/Users/yilinlyu/Documents/sdohplace-toolkit/o4rtestdata/ChiZipMaster1.geojson&#39; ## using driver `GeoJSON&#39; ## Simple feature collection with 540 features and 31 fields ## Geometry type: MULTIPOLYGON ## Dimension: XY ## Bounding box: xmin: -87.87596 ymin: 41.64454 xmax: -87.52414 ymax: 42.02304 ## Geodetic CRS: WGS 84 housing &lt;- na.omit(housing) housing &lt;- st_as_sf(housing, coords = c(&quot;Longitude&quot;, &quot;Latitude&quot;), crs = 4326) # Perform spatial join joined_data &lt;- st_join(zipcode, housing, join = st_intersects) # Count the number of housing developments per ZIP code housing_count &lt;- joined_data %&gt;% group_by(zip) %&gt;% summarise(Count = n()) # Drop the geometry column from housing_count housing_count_nonspatial &lt;- as.data.frame(housing_count) # Perform the join zipcode_with_housing_count &lt;- left_join(zipcode, housing_count_nonspatial, by = &quot;zip&quot;) A.5 Inspect Data ** Once you’ve merged data, you’ll want to inspect and visualize with simple views. Inspect data, both through spatial and non-spatial means, when starting a new project. This helps verify that all data wrangling to this point has occurred properly. In the next module, we’ll dive into the details of this further, moving past inspection to data analytics. A.5.1 Thematic Maps To inspect data from a spatial perspective, create a series of choropleth maps. ** Briefly exlain this without too much detail ** Example 1: Number of Affordable Housing Developments per Zip Code Based on the previous spatial join (join by location) in A.4 with affordable housing development data and ChiZipMaster1.geojson, we can start to generate a choropleth map. plot &lt;- ggplot(data = zipcode_with_housing_count) + geom_sf(aes(fill = Count), color = NA) + scale_fill_viridis_c() + labs(title = &quot;Number of Affordable Housing Developments per Zip Code&quot;, fill = &quot;# Developments&quot;) + theme_minimal() print(plot) Example 2: Number of COVID-19 Cases per Zip Code Chi_Zipsf &lt;- st_read(&quot;o4rtestdata/ChiZipMaster1.geojson&quot;) ## Reading layer `ChiZipMaster1&#39; from data source ## `/Users/yilinlyu/Documents/sdohplace-toolkit/o4rtestdata/ChiZipMaster1.geojson&#39; ## using driver `GeoJSON&#39; ## Simple feature collection with 540 features and 31 fields ## Geometry type: MULTIPOLYGON ## Dimension: XY ## Bounding box: xmin: -87.87596 ymin: 41.64454 xmax: -87.52414 ymax: 42.02304 ## Geodetic CRS: WGS 84 tmap_mode(&quot;plot&quot;) ## tmap mode set to plotting tm_shape(Chi_Zipsf) + tm_fill(&quot;Case.Rate...Cumulative&quot;, style=&quot;jenks&quot;, pal=&quot;BuPu&quot;, n=4, title = &quot;COVID Rt&quot;) + tm_layout(legend.outside = TRUE, legend.outside.position = &quot;right&quot;) A.5.2 Map Overlay Example 1: COVID-19 &amp; Methadone In the first example, let create a map showing both COVID-19 and methadone clinic data (used in A.3). First, let’s add our zipcode map. Chi_Zipsf &lt;- st_read(&quot;o4rtestdata/ChiZipMaster1.geojson&quot;) ## Reading layer `ChiZipMaster1&#39; from data source ## `/Users/yilinlyu/Documents/sdohplace-toolkit/o4rtestdata/ChiZipMaster1.geojson&#39; ## using driver `GeoJSON&#39; ## Simple feature collection with 540 features and 31 fields ## Geometry type: MULTIPOLYGON ## Dimension: XY ## Bounding box: xmin: -87.87596 ymin: 41.64454 xmax: -87.52414 ymax: 42.02304 ## Geodetic CRS: WGS 84 With this overlay, we’ll add a “hack” to include the methadone clinic points in a legend. tmap_mode(&quot;plot&quot;) ## tmap mode set to plotting ## 1st layer (gets plotted first) tm_shape(Chi_Zipsf) + tm_fill(&quot;Case.Rate...Cumulative&quot;, style=&quot;jenks&quot;, pal=&quot;BuPu&quot;, n=4, title = &quot;COVID Rt&quot;) + ## 2nd layer (overlay) tm_shape(methadoneSf) + tm_dots(size = 0.2, col = &quot;gray20&quot;) + ## &quot;Hack&quot; a manual symbology for dots in the legend tm_add_legend(&quot;symbol&quot;, col = &quot;gray20&quot;, size = .2, labels = &quot;Methadone MOUD&quot;) + ## Cartographic Styling tm_layout(legend.outside = TRUE, legend.outside.position = &quot;right&quot;) Example 2: Afforfable Housing Developments &amp; Zipcode Boundaries Previously in A.4, we used a graduated symbology. Points with more units will be bigger, and not all places are weighted the same visually. Now, let’s overlay that layer to the zipcode boundary. tm_shape(Chi_Zipsf) + tm_polygons(col = &quot;gray80&quot;) + tm_shape(AffHousingSf) + tm_bubbles(&quot;Units&quot;, col = &quot;purple&quot;) Then, let’s map everything at once, and explore which zip codes are the most vulnerable to persons with OUD during the pandemic in September 2020, based on the information we have here? ## Zip Codes with Labels tm_shape(Chi_Zipsf) + tm_fill(&quot;Case.Rate...Cumulative&quot;, style=&quot;jenks&quot;, pal=&quot;BuPu&quot;, n=4, title = &quot;COVID Rt&quot;) + ## Affordable Housing Units tm_shape(AffHousingSf) + tm_bubbles(&quot;Units&quot;) + ## Methadone MOUD tm_shape(methadoneSf) + tm_dots(size = 0.2, col = &quot;gray20&quot;) + ## Cartographic Styling tm_add_legend(&quot;symbol&quot;, col = &quot;gray20&quot;, size = .2, labels = &quot;Methadone MOUD&quot;) + tm_layout(legend.outside = TRUE, legend.outside.position = &quot;right&quot;) In RStudio, you could zoom into the plot you created to get a better view. Save as an image, or save as a webpage! Save any data you need from this session. st_write(methadoneSf, dsn = &quot;o4rtestdata/methadoneMOUD.geojson&quot;) Example 3: Zipcode Boundaries &amp; Census Tracts Here is a final example for the overlay. How do census tract areas correspond to zip codes? While tracts better represent neighborhoods, often times we are stuck with zip code level scale in healh research. Here we will practice how to overlay zipcode boundaries, by making a reference map to highlight tract distribution across each zip code. First, we read in zip code boundaries. This data was downloaded directly from the City of Chicago Data Portal as a shapefile. Chi_Zips = st_read(&quot;o4rtestdata/geo_export_54bc15d8-5ef5-40e4-8f72-bb0c6dbac9a5.shp&quot;) ## Reading layer `geo_export_54bc15d8-5ef5-40e4-8f72-bb0c6dbac9a5&#39; from data source `/Users/yilinlyu/Documents/sdohplace-toolkit/o4rtestdata/geo_export_54bc15d8-5ef5-40e4-8f72-bb0c6dbac9a5.shp&#39; ## using driver `ESRI Shapefile&#39; ## Simple feature collection with 61 features and 4 fields ## Geometry type: MULTIPOLYGON ## Dimension: XY ## Bounding box: xmin: -87.94011 ymin: 41.64454 xmax: -87.52414 ymax: 42.02304 ## Geodetic CRS: WGS84(DD) Next, we layer the new shape in – on top of the tracts. We use a thicker border, and try out a new color. Experiment! ## FIRST LAYER: CENSUS TRACT BOUNADRIES tm_shape(Chi_tracts.3435) + tm_fill(col = &quot;gray90&quot;) + tm_borders(alpha=0.2, col = &quot;gray10&quot;) + ## SECOND LAYER: ZIP CODE BOUNDARIES WITH LABEL tm_shape(Chi_Zips) + tm_borders(lwd = 2, col = &quot;#0099CC&quot;) + tm_text(&quot;zip&quot;, size = 0.7) + ## MORE CARTOGRAPHIC STYLE tm_scale_bar(position = (&quot;left&quot;), lwd = 0.8) + tm_layout(frame = F) A.6 Finding Data In this module, we provided sample data to work with. When you’re looking for your own data, …. ** Determine your spatial boundary - get boundary data. Use that as your master file to merge in more. ** Use a conceptual model to guide your variable selection. ** Use existing resources that have aggregated cleaned data to access; or, extract from the Census directly ** OSM data for international work Resources "]]
